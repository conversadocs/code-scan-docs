#!/usr/bin/env python3
"""
Example Markdown Documentation Generator Plugin for CSD.
Generates comprehensive markdown documentation from project matrix.
"""

import sys
from pathlib import Path
from typing import Tuple, Dict, List, Any

# Add the shared directory to the path so we can import base classes
sys.path.insert(0, str(Path(__file__).parent / "../shared"))

from base_output import (
    BaseOutputPlugin,
    OutputPluginInput,
    OutputPluginResult,
    calculate_file_metrics,
    extract_dependencies,
)


class MarkdownDocsPlugin(BaseOutputPlugin):
    """Generate comprehensive Markdown documentation from project matrix."""

    def __init__(self):
        super().__init__()
        self.name = "markdown_docs"
        self.version = "1.0.0"
        self.supported_output_types = ["documentation"]
        self.supported_formats = ["markdown"]

    def can_generate(self, output_type: str, format: str) -> Tuple[bool, float]:
        """Check if this plugin can generate the requested output."""
        if output_type.lower() == "documentation" and format.lower() == "markdown":
            return True, 1.0
        return False, 0.0

    def generate(self, input_data: OutputPluginInput) -> OutputPluginResult:
        """Generate markdown documentation from the project matrix."""
        # Load the matrix data
        matrix_data = self._load_matrix_from_file(input_data.matrix_path)

        # Ensure output directory exists
        self._ensure_output_directory(input_data.output_dir)

        # Generate different documentation files
        outputs = []

        # 1. Project Overview
        overview_path = self._generate_output_filename(
            "project_overview", "markdown", input_data.output_dir
        )
        self._generate_project_overview(matrix_data, overview_path)
        outputs.append(self._create_generated_output(overview_path, "markdown"))

        # 2. File Structure Documentation
        structure_path = self._generate_output_filename(
            "file_structure", "markdown", input_data.output_dir
        )
        self._generate_file_structure(matrix_data, structure_path)
        outputs.append(self._create_generated_output(structure_path, "markdown"))

        # 3. Dependencies Documentation
        deps_path = self._generate_output_filename(
            "dependencies", "markdown", input_data.output_dir
        )
        self._generate_dependencies_doc(matrix_data, deps_path)
        outputs.append(self._create_generated_output(deps_path, "markdown"))

        # 4. API Documentation (if applicable)
        api_path = self._generate_output_filename(
            "api_reference", "markdown", input_data.output_dir
        )
        self._generate_api_documentation(matrix_data, api_path)
        outputs.append(self._create_generated_output(api_path, "markdown"))

        return OutputPluginResult(
            plugin_name=self.name,
            plugin_version=self.version,
            output_type="documentation",
            outputs=outputs,
            metadata={
                "total_files_documented": len(matrix_data.get("files", {})),
                "documentation_sections": len(outputs),
                "matrix_timestamp": matrix_data.get("metadata", {}).get(
                    "scan_timestamp"
                ),
            },
        )

    def _generate_project_overview(self, matrix_data: dict, output_path: str) -> None:
        """Generate the main project overview documentation."""
        metadata = matrix_data.get("metadata", {})
        metrics = calculate_file_metrics(matrix_data)

        content = f"""# Project Overview

## Project Information
- **Project Root**: {metadata.get("project_root", "Unknown")}
- **Last Scanned**: {metadata.get("scan_timestamp", "Unknown")}
- **CSD Version**: {metadata.get("csd_version", "Unknown")}

## Project Statistics
- **Total Files**: {metrics["total_files"]}
- **Total Size**: {metrics["total_size_mb"]:.2f} MB
- **Total Code Elements**: {metrics["total_elements"]}
- **Average Complexity**: {metrics["average_complexity"]:.2f}

## Languages/Technologies
"""

        for plugin, count in metrics["files_by_plugin"].items():
            content += f"- **{plugin.upper()}**: {count} files\n"

        content += f"""
## External Dependencies
Total: {len(matrix_data.get("external_dependencies", []))} dependencies

## Relationships
Total: {len(matrix_data.get("relationships", []))} file relationships

---
*Generated by CSD Markdown Documentation Plugin v{self.version}*
"""

        with open(output_path, "w", encoding="utf-8") as f:
            f.write(content)

    def _generate_file_structure(self, matrix_data: dict, output_path: str) -> None:
        """Generate file structure documentation."""
        files = matrix_data.get("files", {})

        content = """# File Structure

This document provides an overview of all files in the project organized by language.

"""

        # Group files by plugin/language
        by_plugin: Dict[str, List[Tuple[str, Dict[str, Any]]]] = {}
        for file_path, file_info in files.items():
            plugin = file_info.get("plugin", "unknown")
            if plugin not in by_plugin:
                by_plugin[plugin] = []
            by_plugin[plugin].append((file_path, file_info))

        # Sort plugins
        for plugin in sorted(by_plugin.keys()):
            content += f"## {plugin.upper()} Files\n\n"

            # Sort files within plugin
            sorted_files = sorted(by_plugin[plugin], key=lambda x: x[0])

            for file_path, file_info in sorted_files:
                relative_path = file_info.get("relative_path", file_path)
                size_kb = file_info.get("size_bytes", 0) / 1024
                elements = file_info.get("elements", [])

                content += f"### `{relative_path}`\n"
                content += f"- **Size**: {size_kb:.1f} KB\n"
                content += f"- **Elements**: {len(elements)}\n"

                if file_info.get("file_summary"):
                    content += f"- **Summary**: {file_info['file_summary']}\n"

                # List major elements
                if elements:
                    content += "- **Contents**:\n"
                    for element in elements[:10]:  # Limit to first 10
                        element_type = element.get("element_type", "unknown")
                        element_name = element.get("name", "unnamed")
                        content += f"  - {element_type}: `{element_name}`\n"

                    if len(elements) > 10:
                        content += f"  - ... and {len(elements) - 10} more\n"

                content += "\n"

        content += "\n---\n*Generated by CSD Markdown Documentation Plugin*\n"

        with open(output_path, "w", encoding="utf-8") as f:
            f.write(content)

    def _generate_dependencies_doc(self, matrix_data: dict, output_path: str) -> None:
        """Generate dependencies documentation."""
        dependencies_by_ecosystem = extract_dependencies(matrix_data)

        content = """# Dependencies

This document lists all external dependencies used in the project.

"""

        if not dependencies_by_ecosystem:
            content += "No external dependencies found.\n"
        else:
            for ecosystem, deps in sorted(dependencies_by_ecosystem.items()):
                content += f"## {ecosystem.upper()} Dependencies\n\n"

                # Group by dependency type
                by_type: Dict[str, List[Dict[str, Any]]] = {}
                for dep in deps:
                    dep_type = dep.get("dependency_type", "runtime")
                    if dep_type not in by_type:
                        by_type[dep_type] = []
                    by_type[dep_type].append(dep)

                for dep_type in sorted(by_type.keys()):
                    content += f"### {dep_type.title()} Dependencies\n\n"
                    content += "| Package | Version | Source File |\n"
                    content += "|---------|---------|-------------|\n"

                    for dep in sorted(
                        by_type[dep_type], key=lambda x: x.get("name", "")
                    ):
                        name = dep.get("name", "unknown")
                        version = dep.get("version", "unspecified")
                        source = dep.get("source_file", "unknown")
                        content += f"| {name} | {version} | `{source}` |\n"

                    content += "\n"

        content += "\n---\n*Generated by CSD Markdown Documentation Plugin*\n"

        with open(output_path, "w", encoding="utf-8") as f:
            f.write(content)

    def _generate_api_documentation(self, matrix_data: dict, output_path: str) -> None:
        """Generate API reference documentation."""
        files = matrix_data.get("files", {})

        content = """# API Reference

This document provides detailed information about public APIs, functions, and classes.

"""

        # Find all public elements
        public_elements = []
        for file_path, file_info in files.items():
            relative_path = file_info.get("relative_path", file_path)
            elements = file_info.get("elements", [])

            for element in elements:
                # Consider elements public if they don't start with _
                element_name = element.get("name", "")
                metadata = element.get("metadata", {})

                is_public = (
                    not element_name.startswith("_")
                    or metadata.get("is_public", False)
                    or metadata.get("visibility") == "pub"
                )

                if is_public:
                    public_elements.append({"file": relative_path, "element": element})

        if not public_elements:
            content += "No public API elements found.\n"
        else:
            # Group by element type
            by_type: Dict[str, List[Dict[str, Any]]] = {}
            for item in public_elements:
                element_type = item["element"].get("element_type", "unknown")
                if element_type not in by_type:
                    by_type[element_type] = []
                by_type[element_type].append(item)

            for element_type in sorted(by_type.keys()):
                content += f"## {element_type.title()}s\n\n"

                for item in sorted(
                    by_type[element_type], key=lambda x: x["element"].get("name", "")
                ):
                    element = item["element"]
                    file_path = item["file"]

                    name = element.get("name", "unnamed")
                    signature = element.get("signature", "")
                    line_start = element.get("line_start", 0)
                    complexity = element.get("complexity_score")
                    summary = element.get("summary", "")

                    content += f"### `{name}`\n\n"
                    content += f"**File**: `{file_path}:{line_start}`\n\n"

                    if signature:
                        content += f"**Signature**:\n```\n{signature}\n```\n\n"

                    if summary:
                        content += f"**Description**: {summary}\n\n"

                    if complexity:
                        content += f"**Complexity Score**: {complexity}\n\n"

                    # Show function calls if available
                    calls = element.get("calls", [])
                    if calls:
                        content += f"**Calls**: {', '.join(calls[:5])}"
                        if len(calls) > 5:
                            content += f" (and {len(calls) - 5} more)"
                        content += "\n\n"

                    content += "---\n\n"

        content += "\n*Generated by CSD Markdown Documentation Plugin*\n"

        with open(output_path, "w", encoding="utf-8") as f:
            f.write(content)


def main():
    """Main entry point for the plugin."""
    plugin = MarkdownDocsPlugin()
    plugin.run()


if __name__ == "__main__":
    main()
