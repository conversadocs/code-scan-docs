use serde::{Deserialize, Serialize};
use std::path::{Path, PathBuf};

/// Plugin type enumeration to distinguish between input and output plugins
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum PluginType {
    Input,  // Code analyzers (existing functionality)
    Output, // Documentation generators, quality scanners, etc.
}

/// Standard output format that all input plugins must produce
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginOutput {
    pub file_path: PathBuf,
    pub file_hash: String,
    pub elements: Vec<CodeElement>,
    pub imports: Vec<Import>,
    pub exports: Vec<String>,
    pub relationships: Vec<Relationship>,
    pub external_dependencies: Vec<ExternalDependency>,
    pub file_summary: Option<String>,
    pub processing_time_ms: u64,
    pub plugin_version: String,
}

/// Output plugin result structure for documentation generators, quality scanners, etc.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OutputPluginResult {
    pub plugin_name: String,
    pub plugin_version: String,
    pub output_type: String, // "documentation", "quality_report", "security_scan", etc.
    pub outputs: Vec<GeneratedOutput>,
    pub processing_time_ms: u64,
    pub metadata: serde_json::Value,
}

/// Individual output file or result generated by an output plugin
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GeneratedOutput {
    pub output_path: PathBuf,
    pub content_type: String, // "markdown", "html", "json", "pdf", etc.
    pub size_bytes: u64,
    pub checksum: String,
    pub metadata: serde_json::Value,
}

/// Code element structure for plugin communication (uses strings, not enums)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CodeElement {
    pub element_type: String, // "function", "class", "method", etc.
    pub name: String,
    pub signature: Option<String>,
    pub line_start: u32,
    pub line_end: u32,
    pub summary: Option<String>,
    pub complexity_score: Option<u32>,
    pub calls: Vec<String>,
    pub metadata: serde_json::Value,
}

/// Import structure for plugin communication
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Import {
    pub module: String,
    pub items: Vec<String>,
    pub alias: Option<String>,
    pub line_number: u32,
    pub import_type: String, // "standard", "third_party", "local", "relative"
}

/// Relationship structure for plugin communication
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Relationship {
    pub from_file: String,
    pub to_file: String,
    pub relationship_type: String, // "import", "call", "inheritance", etc.
    pub details: String,
    pub line_number: Option<u32>,
    pub strength: f32,
}

/// External dependency structure for plugin communication
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExternalDependency {
    pub name: String,
    pub version: Option<String>,
    pub ecosystem: String,       // "pip", "npm", "cargo", etc.
    pub dependency_type: String, // "runtime", "development", "build", "optional"
    pub source_file: String,
}

/// Input sent to input plugins for code analysis
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginInput {
    pub file_path: PathBuf,
    pub relative_path: PathBuf,
    pub content: String,
    pub project_root: PathBuf,
    pub cache_dir: String,
    pub plugin_config: Option<serde_json::Value>,
}

/// Input sent to output plugins for generating documentation, reports, etc.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OutputPluginInput {
    pub matrix_path: PathBuf,
    pub project_root: PathBuf,
    pub output_dir: PathBuf,
    pub cache_dir: String,
    pub plugin_config: Option<serde_json::Value>,
    pub format_options: serde_json::Value, // Plugin-specific formatting options
}

/// Plugin communication protocol - now supports both input and output plugins
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum PluginMessage {
    #[serde(rename = "analyze")]
    Analyze { input: PluginInput },

    #[serde(rename = "generate")]
    Generate { input: OutputPluginInput },

    #[serde(rename = "can_analyze")]
    CanAnalyze {
        file_path: PathBuf,
        content_preview: String,
    },

    #[serde(rename = "can_generate")]
    CanGenerate { output_type: String, format: String },

    #[serde(rename = "get_info")]
    GetInfo,
}

/// Plugin response protocol - now supports both types
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "status")]
pub enum PluginResponse {
    #[serde(rename = "success")]
    Success {
        cache_file: String,
        processing_time_ms: u64,
    },

    #[serde(rename = "output_success")]
    OutputSuccess { result: OutputPluginResult },

    #[serde(rename = "can_analyze")]
    CanAnalyze { can_analyze: bool, confidence: f32 },

    #[serde(rename = "can_generate")]
    CanGenerate { can_generate: bool, confidence: f32 },

    #[serde(rename = "info")]
    Info {
        name: String,
        version: String,
        plugin_type: PluginType, // NEW: Plugin type identification
        supported_extensions: Vec<String>,
        supported_filenames: Vec<String>,
        supported_output_types: Option<Vec<String>>, // For output plugins
        supported_formats: Option<Vec<String>>,      // For output plugins
    },

    #[serde(rename = "error")]
    Error {
        message: String,
        details: Option<String>,
    },
}

/// Trait for implementing plugin communication - now generic over plugin type
#[async_trait::async_trait]
pub trait PluginInterface {
    async fn get_info(&self) -> anyhow::Result<PluginInfo>;
    async fn get_plugin_type(&self) -> anyhow::Result<PluginType>;
}

/// Trait specifically for input plugins (code analyzers)
#[async_trait::async_trait]
pub trait InputPluginInterface: PluginInterface {
    async fn can_analyze(&self, file_path: &Path, content_preview: &str) -> anyhow::Result<bool>;
    async fn analyze(&self, input: PluginInput) -> anyhow::Result<PluginOutput>;
}

/// Trait specifically for output plugins (documentation generators, etc.)
#[async_trait::async_trait]
pub trait OutputPluginInterface: PluginInterface {
    async fn can_generate(&self, output_type: &str, format: &str) -> anyhow::Result<bool>;
    async fn generate(&self, input: OutputPluginInput) -> anyhow::Result<OutputPluginResult>;
    async fn get_supported_output_types(&self) -> anyhow::Result<Vec<String>>;
    async fn get_supported_formats(&self) -> anyhow::Result<Vec<String>>;
}

/// Enhanced plugin info structure with type identification
#[derive(Debug, Clone)]
pub struct PluginInfo {
    pub name: String,
    pub version: String,
    pub plugin_type: PluginType, // NEW: Plugin type identification
    pub supported_extensions: Vec<String>,
    pub supported_filenames: Vec<String>,
    pub supported_output_types: Option<Vec<String>>, // For output plugins
    pub supported_formats: Option<Vec<String>>,      // For output plugins
}

impl PluginInfo {
    /// Check if this is an input plugin
    pub fn is_input_plugin(&self) -> bool {
        self.plugin_type == PluginType::Input
    }

    /// Check if this is an output plugin
    pub fn is_output_plugin(&self) -> bool {
        self.plugin_type == PluginType::Output
    }

    /// Get capabilities description for display
    pub fn get_capabilities_description(&self) -> String {
        match self.plugin_type {
            PluginType::Input => {
                let mut caps = Vec::new();
                if !self.supported_extensions.is_empty() {
                    caps.push(format!(
                        "Extensions: {}",
                        self.supported_extensions.join(", ")
                    ));
                }
                if !self.supported_filenames.is_empty() {
                    caps.push(format!("Files: {}", self.supported_filenames.join(", ")));
                }
                caps.join(" | ")
            }
            PluginType::Output => {
                let mut caps = Vec::new();
                if let Some(ref types) = self.supported_output_types {
                    caps.push(format!("Types: {}", types.join(", ")));
                }
                if let Some(ref formats) = self.supported_formats {
                    caps.push(format!("Formats: {}", formats.join(", ")));
                }
                caps.join(" | ")
            }
        }
    }
}

/// Factory for creating appropriate plugin interface based on type
pub struct PluginFactory;

impl PluginFactory {
    /// Determine plugin type by querying the plugin
    pub async fn detect_plugin_type(plugin_path: &Path) -> anyhow::Result<PluginType> {
        use crate::plugins::communication::PluginCommunicator;

        let communicator = PluginCommunicator::new(plugin_path.to_path_buf());
        let info = communicator.get_info().await?;
        Ok(info.plugin_type)
    }

    /// Create appropriate plugin communicator based on detected type
    pub async fn create_plugin_communicator(
        plugin_path: PathBuf,
    ) -> anyhow::Result<Box<dyn PluginInterface + Send + Sync>> {
        let plugin_type = Self::detect_plugin_type(&plugin_path).await?;

        match plugin_type {
            PluginType::Input => Ok(Box::new(
                crate::plugins::communication::InputPluginCommunicator::new(plugin_path),
            )),
            PluginType::Output => Ok(Box::new(
                crate::plugins::communication::OutputPluginCommunicator::new(plugin_path),
            )),
        }
    }
}
